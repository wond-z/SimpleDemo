<!DOCTYPE html>
<html>

<head>
    <title>Sketchpad demo</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
        }
        #root {
            width: 100%;
            height: 100%;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="root" >
        <canvas id="canvas"></canvas>
    </div>
    <script type="text/javascript">
        let isDown = false;
        let points = []; // 记录点记录
        let beginPoint = null; // 开始点
        const canvas = document.querySelector('#canvas');
        const ctx = canvas.getContext('2d');

        // 记录容器初始加载尺寸
        const originWidth = canvas.parentElement.offsetWidth;
        const originHeight = canvas.parentElement.offsetHeight - 2;

        canvas.width = originWidth;
        canvas.height = originHeight;
        // 记录页面尺寸变化后的宽度和高度的变化率（当前尺寸/原始尺寸）
        let scaleW = 1;
        let scaleH = 1;

        // 设置线条颜色
        // ctx.strokeStyle = 'red';
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        canvas.addEventListener('mousedown', mouseDown, false);
        canvas.addEventListener('mousemove', mouseMove, false);
        canvas.addEventListener('mouseup', mouseUp, false);
        canvas.addEventListener('mouseout', mouseUp, false);
        // 移动端
        canvas.addEventListener('touchstart', touchStart, false);
        canvas.addEventListener('touchmove', touchMove, false);
        canvas.addEventListener('touchend', touchEnd, false);

        // 鼠标按下事件
        function mouseDown(evt) {
            isDown = true;
            const { x, y } = getPos(evt);
            points.push({ x, y });
            beginPoint = { x, y };
        }

        // 鼠标移动
        function mouseMove(evt) {
            if (!isDown) return;

            const { x, y } = getPos(evt);
            points.push({ x, y });

            if (points.length > 2) {
                const lastTwoPoints = points.slice(-2);
                const controlPoint = lastTwoPoints[0];
                const endPoint = {
                    x: (lastTwoPoints[0].x + lastTwoPoints[1].x) / 2,
                    y: (lastTwoPoints[0].y + lastTwoPoints[1].y) / 2,
                }
                drawLine(beginPoint, controlPoint, endPoint);
                beginPoint = endPoint;
            }
        }

        // 鼠标抬起
        function mouseUp(evt) {
            if (!isDown) return;
            const { x, y } = getPos(evt);
            points.push({ x, y });

            if (points.length > 2) {
                const lastTwoPoints = points.slice(-2);
                const controlPoint = lastTwoPoints[0];
                const endPoint = lastTwoPoints[1];
                drawLine(beginPoint, controlPoint, endPoint);
            }
            beginPoint = null;
            isDown = false;
            points = [];
        }

        // 触控开始
        function touchStart (e) {
            e.preventDefault();
            isDown = true;
            if (e.touches.length === 1) {
                const { x, y } = getPosMobile(e);
                points.push({ x, y });
                beginPoint = { x, y };
            }
        }

        // 触控移动
        function touchMove (e) {
            e.preventDefault();
            if (!isDown) return;
            if (e.touches.length === 1) {
                const { x, y } = getPosMobile(e);
                points.push({ x, y });

                if (points.length > 2) {
                    const lastTwoPoints = points.slice(-2);
                    const controlPoint = lastTwoPoints[0];
                    const endPoint = {
                        x: (lastTwoPoints[0].x + lastTwoPoints[1].x) / 2,
                        y: (lastTwoPoints[0].y + lastTwoPoints[1].y) / 2,
                    }
                    drawLine(beginPoint, controlPoint, endPoint);
                    beginPoint = endPoint;
                }
            }
        }

        // 触控结束
        function touchEnd (e) {
            e.preventDefault();
            if (!isDown) return;

            if (e.touches.length === 1) {
                const { x, y } = getPos(evt);
                points.push({ x, y });

                if (points.length > 2) {
                    const lastTwoPoints = points.slice(-2);
                    const controlPoint = lastTwoPoints[0];
                    const endPoint = lastTwoPoints[1];
                    drawLine(beginPoint, controlPoint, endPoint);
                }
            }
            beginPoint = null;
            isDown = false;
            points = [];
        }

        // 画线
        function drawLine(beginPoint, controlPoint, endPoint) {
            ctx.beginPath();
            ctx.moveTo(beginPoint.x / scaleW, beginPoint.y / scaleH);
            // lineTo方法绘制的线条是折现，不够平滑，这里使用quadraticCurveTo方法绘制二次贝塞尔曲线，https://juejin.cn/post/6844903692747948039
            ctx.quadraticCurveTo(controlPoint.x / scaleW, controlPoint.y / scaleH, endPoint.x / scaleW, endPoint.y / scaleH);
            ctx.strokeStyle = 'green';
            ctx.stroke();
            ctx.closePath();
        }

        // 屏幕自适应（计算缩放比例）
        const resetSize = () => {
            // 获取当前父容器宽度
            const currentWidth = canvas.parentElement.offsetWidth;
            // 获取当前父容器高度
            const currentHeight = canvas.parentElement.offsetHeight - 2;

            // 获取当前宽度和初始宽度比例
            scaleW = currentWidth / originWidth;
            // 获取当前高度和初始高度比例
            scaleH = currentHeight / originHeight;
        }
        window.onresize = resetSize;

        // 判断是否是移动端
        function isMobile(){
            if (window.navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)) {
                return true; // 移动端
            }
            return false; // PC端
        }

        // 获取事件中的点点坐标信息
        function getPos(evt) {
            return {
                x: evt.clientX,
                y: evt.clientY
            }
        }

        // 移动端获取当前事件中的点位置
        function getPosMobile(evt) {
            return {
                x: evt.targetTouches[0].clientX - canvas.getBoundingClientRect().left,
                y: evt.targetTouches[0].clientY - canvas.getBoundingClientRect().top
            }
        }
    </script>
</body>

</html>